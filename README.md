# Raptor Test Utils v1.0.0

(c) Mikhail Kamorin aka raptor_MVK

## Overview

Package contains following components:
- trait `ExtraUtils` that contains set of service methods used to make testing easier
- trait `ExtraAssertions` that contains set of additional assertions
- trait `WithVFS` that provides adapted interface for `mikey179/vfsstream` (virtual file system)
- test data loader from JSON files that wraps each test case into test data container
- command `generate-ide-test-containers` that generate service file for IDE used to autocomplete

## Installation

The suggested installation method is via [composer](https://getcomposer.org/):

```sh
php composer.phar require "raptor/test-utils:1.0.*"
```

## Usage

### Additional service methods

Add trait `ExtraUtils` or `ExtraAssertions` to the class with tests or common base test class. After that the following
static methods will be available:

 - `invokeMethod(object $object, string $methodName, ?array $parameters = null)` вызывает защищённый или приватный метод
    объекта с указанными параметрами

### Дополнительные утверждения

В класс, содержащий тесты, или в базовый для всех тестов класс необходимо подключить трейт `ExtraAssertions`. После
этого становятся доступны следующие дополнительные утверждения:

 - `assertArraysAreSame(array $expected, array $actual, ?string $message = null)` проверяет утверждение, что массивы
    полностью идентичны (совпадают порядок элементов, их типы, включая все вложенные массивы), при проверке происходит
    преобразование в JSON-строку, соответственно, не поддерживаются объекты и функции как элементы массива
 - `assertArraysAreSameIgnoringOrder(array $expected, array $actual, ?string $message = null)` проверяет утверждение,
    что массивы содержат одинаковые элементы, для ассоциативных массивов при этом порядок элементов не важен (на верхнем
    уровне, для всех вложенных ассоциативных массивов порядок важен), при проверке происходит преобразование в
    JSON-строку, соответственно, не поддерживаются объекты и функции как элементы массива
 - `assertArraysAreSameIgnoringOrderRecursive(array $expected, array $actual, ?string $message = null)` проверяет
    утверждение, что массивы содержат одинаковые элементы, для ассоциативных массивов при этом порядок элементов не
    важен, в том числе для всех вложенных ассоциативных массивов, при проверке происходит преобразование в JSON-строку,
    соответственно, не поддерживаются объекты и функции как элементы массива
 - `assertStringIsSameAsFile(string $expected, string $actual, ?string $message = null)` проверяет утверждение, что
    строка совпадает с содержимым файла

### Виртуальная файловая система

В класс, содержащий тесты или в базовый для всех тестов класс необходимо подключить трейт `WithVFS`. В методе `setUp`
или в тестирующих методах перед вызовом методов трейта обязательно необходимо вызывать метод `setupVFS`. После этого
становятся доступны новые методы:

 - `addFileToVFS(string $filename, ?int $permissions = null, ?string $content = null)` добавляет файл с указанными
   правами (целое число, соответствующее unix-правам) и содержимым, путь указывается внутри виртуальной файловой системы
 - `addDirectoryToVFS(string $dirname, ?int $permissions = null)` добавляет директорию с указанными правами (целое
   число, соответствующее unix-правам), путь указывается внутри виртуальной файловой системы
 - `addStructure(array $structure)` добавляет структуру директорий в виртуальную файловую систему, структура директорий
   задаётся в формате дерева, листьями являются файлы, где ключ элемента массива - имя файла, а значение - его
   содержимое
 - `getFullPath(string $path)` возвращает полный путь к файлу по его пути внутри виртуальной файловой системы,
   предназначен для передачи в функции для непосредственной работы с файлами
 - `getEscapedFullPath(string $path)` возвращает полный путь к файлу по его пути внутри виртуальной файловой системы с
   экранированием для использования в регулярных выражениях

### Загрузчик тестовых данных

Загрузчик позволяет выделить тестовые данные из провайдера в коде в отдельный JSON-файл. В результате загрузки из файла
формируется набор именованных тестовых данных, где данные для каждого теста обёрнуты в объект-контейнер. Значения
конкретных полей из файла возвращаются геттерами. Данный механизм позволяет решить следующие задачи:
 - выделение тестовых данных из кода
 - возможность передачи в тестирующий метод большого количества параметров без раздувания сигнатуры метода
 - возможность иерархической организации тестовых данных, когда различия данных между тестами незначительны

Требования к JSON-файлу:
 - файл должен содержать **массив** JSON-объектов, массив может содержать единственный объект
 - имена всех полей объектов не должны начинаться с символа подчёркивания, кроме специально оговоренных ниже случаев
 - имена всех полей могут содержать только строчные буквы, цифры и символ подчёркивания
 - каждый объект в массиве должен быть одного из двух типов:
     1. объект 1-го типа содержит набор тестовых данных. В этом случае в объекте **не должно быть** служебного поля
        `_children` и **должно быть** служебное поле `_name`
     2. объект 2-го типа содержит массив наборов тестовых данных с заданными значениями по умолчанию для некоторых
        полей. В этом случае в объекте **должно быть** служебное поле `_children` и **не должно быть** служебного поля
        `_name`
 - служебное поле `_name` должно быть строковым, оно содержит название тестового набора данных
 - значения служебного поля `_name` должны быть уникальны и непусты
 - служебное поле `_children` должно содержать массив, к которому предъявляются те же требования, что и к корневому
   массиву файла

При обработке файла для объектов 1-го типа выполняется следующий алгоритм:
 - если данный объект имеет объект-родителя 2-го типа, то перебираются все неслужебные поля объекта-родителя
 - для каждого поля проверяется, задано ли значение этого поля для рассматриваемого объекта 1-го типа; если это не так,
   то для этого поля задаётся значение из объекта-родителя
 - если объект-родитель также имеет объект-родителя 2-го типа, то процедура повторяется для него
 
Промежуточным результатом работы загрузчика является массив, содержащий все полученные объекты 1-го типа с ключами,
являющимися значениями служеного поля `_name` в этих объектах. Само поле `_name` из объектов исключается.

Затем для каждого элемента массива значение оборачивается в объект-контейнер `TestDataContainer`. Данные
достаются из контейнера с помощью геттеров. Наименования геттеров следуют стандартным соглашениям:
 - если имя поля начинается с is, то наименование геттера получается преобразованием в CamelCase имени поля;
 - иначе наименование геттера получается преобразованием в CamelCase имени поля с добавлением префикса `get`.

### Генератор вспомогательного файла для IDE

Вспомогательного файла для IDE нужен для автодополнения при использовании объектов-контейнеров. Генератор запускается
командой

```bash
    php vendor/raptor/test-utils/generate-ide-test-containers path
```

где `path` - путь к директории, в которой расположены JSON-файлы с тестовыми данными. Директория разбирается рекурсивно.
Требования к JSON-файлам:
 - имя каждого JSON-файла преобразуется в StudlyCase (для префикса имени класса) с отбрасыванием расширения, после этого
   преобразования все JSON-файлы должны иметь разные имена. Повторяющиеся имена не будут обработаны
 - каждый JSON-файл должен удовлетворять условиям из раздела **Загрузчик тестовых данных**

В результате выполнения команды в корне проекта генерируется файл _ide_test_containers.php, который содержит
класс-контейнер для каждого JSON-файла в указанной директории. Класс-контейнер расположен в корневом пространстве имён
и имеет название, получаемое преобразованием имени JSON-файла в StudlyCase и добавлением суффикса `DataContainer`. Для
того, чтобы работало автодополнение, необходимо использовать PHPDoc-комментарий `@var` с нужным классом.

### Пример кода для загрузки данных с использованием вспомогательного файла

```php
    use Raptor\Test\DataLoader\DataLoaderFactory;
    use Raptor\Test\TestDataContainer\TestDataContainer;

    class someTests extends TestCase
    {
        ...
        
        private $dataLoader;
        
        ...
        
        protected function setUp(): void
        {
            parent::setUp();
            $this->dataLoader = DataLoaderFactory::createTestContainerWrapperDataLoader();
            
            ...
        }
        
        ...
        
        /**
         * @dataProvider someDataProvider
         */
        public function testSomething(TestDataContainer $dataContainer): void
        {
            /** @var \SomeTestsDataContainer $dataContainer */
            $value = $dataContainer->getValue();
            ...
        }
        
        public function someDataProvider(): array
        {
            return $this->dataLoader->load('some_tests.json'); 
        }
        
        ...
    }
```

## Авторы

- Михаил Каморин aka raptor_MVK
